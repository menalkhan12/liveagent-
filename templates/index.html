<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0d1b2e" />
  <title>IST Voice Assistant</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet" />

  <style>
    :root {
      --bg:        #0d1b2e;
      --bg2:       #112240;
      --card:      #162035;
      --border:    rgba(255,255,255,0.08);
      --blue:      #3b82f6;
      --green:     #10b981;
      --red:       #ef4444;
      --text:      #e2eaf7;
      --muted:     #8899b4;
      --agent-bg:  #1a2d4a;
      --user-bg:   #1e3a5f;
      --radius:    14px;
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', sans-serif;
      overflow-x: hidden;
      -webkit-tap-highlight-color: transparent;
    }

    /* â”€â”€ Shell â”€â”€ */
    .shell {
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 32px 16px env(safe-area-inset-bottom, 16px);
      max-width: 760px;
      margin: 0 auto;
    }

    /* â”€â”€ Hero header â”€â”€ */
    .hero {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      margin-bottom: 28px;
      text-align: center;
    }
    .mic-icon-box {
      width: 72px; height: 72px;
      border-radius: 20px;
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      display: flex; align-items: center; justify-content: center;
      font-size: 34px;
      box-shadow: 0 8px 32px rgba(59,130,246,0.35);
      flex-shrink: 0;
    }
    .hero h1 {
      font-size: 28px;
      font-weight: 800;
      color: #fff;
      letter-spacing: -0.02em;
      line-height: 1.15;
    }
    .hero p {
      font-size: 15px;
      color: var(--muted);
      font-weight: 400;
    }

    /* â”€â”€ Status bar â”€â”€ */
    .status-bar {
      width: 100%;
      padding: 14px 20px;
      border-radius: var(--radius);
      background: var(--card);
      border: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 14px;
      font-size: 15px;
      font-weight: 500;
      min-height: 52px;
    }
    .status-dot {
      width: 10px; height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
      background: var(--muted);
      transition: background 0.3s;
    }
    .status-dot.offline  { background: var(--muted); }
    .status-dot.active   { background: var(--green); box-shadow: 0 0 8px var(--green); animation: pulse 1.8s infinite; }
    .status-dot.recording{ background: var(--red);   box-shadow: 0 0 8px var(--red);   animation: pulse 0.9s infinite; }
    .status-dot.thinking { background: #a78bfa;      box-shadow: 0 0 8px #a78bfa;      animation: pulse 1s infinite; }
    @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.3} }
    #status-text { color: var(--green); }
    #status-text.offline { color: var(--muted); }

    /* â”€â”€ Button row â”€â”€ */
    .btn-row {
      display: flex;
      gap: 12px;
      width: 100%;
      margin-bottom: 20px;
    }
    .btn {
      flex: 1;
      padding: 16px;
      border-radius: var(--radius);
      border: none;
      font-family: 'Inter', sans-serif;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.18s;
      display: flex; align-items: center; justify-content: center;
      gap: 8px;
      touch-action: manipulation;
      letter-spacing: 0.01em;
    }
    .btn:active { transform: scale(0.97); }
    .btn.start {
      background: linear-gradient(135deg, #10b981, #059669);
      color: #fff;
      box-shadow: 0 4px 20px rgba(16,185,129,0.35);
    }
    .btn.start:hover { background: linear-gradient(135deg, #34d399, #10b981); }
    .btn.end {
      background: linear-gradient(135deg, rgba(239,68,68,0.22), rgba(185,28,28,0.15));
      color: #fca5a5;
      border: 1px solid rgba(239,68,68,0.45);
    }
    .btn.end:hover:not(:disabled) { background: linear-gradient(135deg, rgba(239,68,68,0.38), rgba(185,28,28,0.28)); }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; pointer-events: none; }

    /* â”€â”€ iOS mic button (shown only on iOS after call starts) â”€â”€ */
    .mic-wrap {
      width: 100%;
      display: none;  /* hidden by default, shown on iOS */
      justify-content: center;
      margin-bottom: 16px;
      position: relative;
    }
    .mic-ring {
      position: absolute;
      border-radius: 50%;
      border: 2px solid var(--blue);
      opacity: 0;
    }
    .mic-ring.r1 { width: 88px; height: 88px; }
    .mic-ring.r2 { width: 110px; height: 110px; }
    .recording .mic-ring { animation: ringPulse 1.4s ease-out infinite; }
    .recording .mic-ring.r2 { animation-delay: 0.4s; }
    @keyframes ringPulse {
      0%   { opacity: 0.7; transform: scale(0.85); }
      100% { opacity: 0;   transform: scale(1.1); }
    }
    #mic-btn {
      width: 72px; height: 72px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(135deg, #1d4ed8, #2563eb);
      box-shadow: 0 4px 24px rgba(37,99,235,0.5);
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      font-size: 28px;
      position: relative;
      z-index: 1;
      transition: transform 0.15s, background 0.2s;
      touch-action: manipulation;
    }
    #mic-btn:active { transform: scale(0.92); }
    #mic-btn.recording {
      background: linear-gradient(135deg, #991b1b, #dc2626);
      box-shadow: 0 4px 24px rgba(220,38,38,0.55);
    }
    #mic-btn.disabled {
      background: #1e293b;
      box-shadow: none;
      cursor: not-allowed;
      opacity: 0.5;
    }

    /* â”€â”€ Chat area â”€â”€ */
    .chat-box {
      width: 100%;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px;
      min-height: 220px;
      max-height: 420px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
      scrollbar-width: thin;
      scrollbar-color: rgba(255,255,255,0.1) transparent;
    }
    .chat-box::-webkit-scrollbar { width: 5px; }
    .chat-box::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 4px; }

    /* Bubbles */
    .msg {
      max-width: 88%;
      padding: 11px 15px;
      border-radius: 12px;
      font-size: 15px;
      line-height: 1.55;
      animation: fadeUp 0.3s ease forwards;
      opacity: 0;
    }
    @keyframes fadeUp { to { opacity: 1; transform: translateY(0); } from { opacity:0; transform: translateY(6px); } }
    .msg.agent {
      align-self: flex-start;
      background: var(--agent-bg);
      color: #d4eaff;
      border: 1px solid rgba(59,130,246,0.15);
    }
    .msg.user {
      align-self: flex-end;
      background: var(--user-bg);
      color: #c7e0ff;
      border: 1px solid rgba(59,130,246,0.2);
    }
    .msg-status {
      align-self: flex-start;
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 14px;
      font-style: italic;
      padding: 4px 2px;
    }
    .spinner {
      width: 16px; height: 16px;
      border: 2px solid rgba(255,255,255,0.15);
      border-top-color: #a78bfa;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
      flex-shrink: 0;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .placeholder {
      color: var(--muted);
      font-size: 14px;
      text-align: center;
      padding: 24px 0;
      font-style: italic;
    }

    /* â”€â”€ Toast â”€â”€ */
    #toast {
      position: fixed;
      bottom: calc(env(safe-area-inset-bottom,16px) + 16px);
      left: 50%;
      transform: translateX(-50%) translateY(60px);
      background: #1e293b;
      border: 1px solid rgba(255,255,255,0.1);
      color: var(--text);
      font-size: 13px;
      padding: 10px 22px;
      border-radius: 99px;
      z-index: 200;
      transition: transform 0.3s cubic-bezier(0.34,1.56,0.64,1), opacity 0.3s;
      opacity: 0;
      pointer-events: none;
      max-width: 90vw;
      text-align: center;
    }
    #toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }

    /* â”€â”€ Info chips â”€â”€ */
    .info-strip {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 14px;
      width: 100%;
    }
    .chip {
      font-size: 11px;
      color: var(--muted);
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 4px 10px;
      letter-spacing: 0.04em;
    }

    @media (max-width: 400px) {
      .hero h1 { font-size: 22px; }
      .btn { font-size: 15px; padding: 14px; }
    }
  </style>
</head>

<body>
  <div class="shell">

    <!-- Hero -->
    <div class="hero">
      <div class="mic-icon-box">ğŸ™</div>
      <h1>Institute of Space Technology</h1>
      <p>Voice Assistant â€” Ask anything about admissions</p>
    </div>

    <!-- Status bar -->
    <div class="status-bar">
      <span class="status-dot offline" id="status-dot"></span>
      <span id="status-text" class="offline">Offline â€” Click Start to begin</span>
    </div>

    <!-- Start / End buttons -->
    <div class="btn-row">
      <button class="btn start" id="start-btn" onclick="startCall()">â–¶ Start Call</button>
      <button class="btn end"   id="end-btn"   onclick="endCall()" disabled>â–  End Call</button>
    </div>

    <!-- iOS mic button (shown after call starts on iOS) -->
    <div class="mic-wrap" id="mic-wrap">
      <div class="mic-ring r1"></div>
      <div class="mic-ring r2"></div>
      <button id="mic-btn" class="disabled" disabled>ğŸ™</button>
    </div>

    <!-- Chat -->
    <div class="chat-box" id="transcript">
      <div class="placeholder" id="transcript-placeholder">Your conversation will appear here</div>
    </div>

    <!-- Info -->
    <div class="info-strip">
      <div class="chip" id="chip-platform">Detectingâ€¦</div>
      <div class="chip" id="chip-codec">Codec: â€”</div>
      <div class="chip">IST Admissions AI</div>
    </div>
  </div>

  <div id="toast"></div>

  <script>
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     STATE
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  let sessionId       = null;
  let mediaRecorder   = null;
  let recordingChunks = [];
  let isRecording     = false;
  let callActive      = false;
  let mimeType        = 'audio/webm';
  let currentAudio    = null;

  const isIOS     = /iphone|ipad|ipod|crios|fxios/i.test(navigator.userAgent);
  const isAndroid = /android/i.test(navigator.userAgent);
  const useVAD    = !isIOS;

  function detectMimeType() {
    const candidates = isIOS
      ? ['audio/mp4','audio/aac','audio/mpeg','audio/webm;codecs=opus','audio/webm']
      : ['audio/webm;codecs=opus','audio/webm','audio/ogg;codecs=opus','audio/ogg','audio/mp4'];
    for (const m of candidates)
      if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) return m;
    return '';
  }

  function mimeToExt(mime) {
    if (mime.includes('mp4')||mime.includes('aac')||mime.includes('m4a')) return 'mp4';
    if (mime.includes('ogg'))  return 'ogg';
    if (mime.includes('mpeg')) return 'mp3';
    return 'webm';
  }

  document.getElementById('chip-platform').textContent =
    isIOS ? 'Platform: iOS' : isAndroid ? 'Platform: Android' : 'Platform: Desktop';

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     UI HELPERS
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  function setStatus(mode, label) {
    const dot  = document.getElementById('status-dot');
    const text = document.getElementById('status-text');
    dot.className  = 'status-dot ' + mode;
    text.className = mode === 'offline' ? 'offline' : '';
    text.textContent = label;
  }

  function showToast(msg, dur = 2800) {
    const t = document.getElementById('toast');
    t.textContent = msg; t.classList.add('show');
    setTimeout(() => t.classList.remove('show'), dur);
  }

  function setMicState(state) {
    const btn  = document.getElementById('mic-btn');
    const wrap = document.getElementById('mic-wrap');
    btn.className = ''; wrap.className = 'mic-wrap';
    if (state === 'idle')      { btn.classList.add('disabled'); btn.disabled = true;  btn.textContent = 'ğŸ™'; }
    else if (state === 'ready'){ btn.disabled = false; btn.textContent = 'ğŸ™'; }
    else if (state === 'speaking') { btn.disabled = false; btn.textContent = 'ğŸ™'; }
    else if (state === 'recording'){ btn.classList.add('recording'); wrap.classList.add('recording'); btn.disabled = false; btn.textContent = 'â¹'; }
    else if (state === 'thinking') { btn.classList.add('disabled'); btn.disabled = true; btn.textContent = 'â³'; }
  }

  function addBubble(text, who) {
    const box = document.getElementById('transcript');
    const ph  = document.getElementById('transcript-placeholder');
    if (ph) ph.remove();
    removeStatusMsg();
    const div = document.createElement('div');
    div.className = 'msg ' + who;
    div.textContent = (who === 'agent' ? 'ğŸ¤– ' : 'ğŸ¤ ') + text;
    box.appendChild(div);
    box.scrollTop = box.scrollHeight;
    return div;
  }

  let statusMsgEl = null;
  function showStatusMsg(text) {
    removeStatusMsg();
    const box = document.getElementById('transcript');
    const ph  = document.getElementById('transcript-placeholder');
    if (ph) ph.remove();
    const div = document.createElement('div');
    div.className = 'msg-status';
    div.id = 'status-msg';
    div.innerHTML = '<div class="spinner"></div><span>' + text + '</span>';
    box.appendChild(div);
    box.scrollTop = box.scrollHeight;
    statusMsgEl = div;
  }

  function removeStatusMsg() {
    const el = document.getElementById('status-msg');
    if (el) el.remove();
    statusMsgEl = null;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     AUDIO PLAYBACK
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  function playAudio(url) {
    return new Promise(resolve => {
      const audio   = new Audio();
      audio.preload = 'auto';
      currentAudio  = audio;
      if (isIOS) {
        audio.setAttribute('playsinline','true');
        audio.setAttribute('webkit-playsinline','true');
      }
      audio.onended  = () => { currentAudio = null; resolve(); };
      audio.onerror  = () => { currentAudio = null; resolve(); };
      audio.oncanplaythrough = () => audio.play().catch(() => { currentAudio = null; resolve(); });
      audio.src = url + (url.includes('?') ? '&' : '?') + '_t=' + Date.now();
    });
  }

  function interruptAudio() {
    if (currentAudio) {
      currentAudio.onended = null; currentAudio.onerror = null;
      currentAudio.pause(); currentAudio.src = '';
      currentAudio = null;
    }
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     AUDIO QUEUE
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  let audioQueue = [], queuePlaying = false, queueDoneCallback = null;

  async function drainQueue() {
    if (queuePlaying) return;
    queuePlaying = true;
    while (audioQueue.length > 0 && callActive) {
      const url = audioQueue.shift();
      await playAudio(url);
      if (!currentAudio && audioQueue.length === 0) break;
    }
    queuePlaying = false;
    if (queueDoneCallback) { queueDoneCallback(); queueDoneCallback = null; }
  }

  function enqueueAudio(url) { audioQueue.push(url); drainQueue(); }
  function clearQueue() { audioQueue = []; interruptAudio(); queuePlaying = false; }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     VAD  (Android / Desktop)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  let vadStream=null, vadAudioCtx=null, vadAnalyser=null;
  let vadRecorder=null, vadChunks=[];
  let vadActive=false, vadSpeaking=false, vadPaused=false;
  let vadSilenceTimer=null, vadSpeakTimer=null, vadAnimFrame=null;
  let vadSpeechStart=0;
  let agentSpeaking   = false;  // true while agent audio is playing
  let requestInFlight = false;  // true while processing a user query

  // Normal listening â€” rejects typing, doors, distant background voices
  const VAD_THRESHOLD_NORMAL   = 0.013;
  const VAD_CONFIRM_NORMAL_MS  = 350;

  // Barge-in mode â€” stricter, needs deliberate close voice to interrupt agent
  const VAD_THRESHOLD_BARGEIN  = 0.025;
  const VAD_CONFIRM_BARGEIN_MS = 500;

  const VAD_SILENCE_MS         = 1300;
  const VAD_MIN_SPEECH_MS      = 500;  // clips shorter than this are noise, ignored

  function getRMS(data) {
    let s=0;
    for (let i=0;i<data.length;i++) { const v=(data[i]-128)/128; s+=v*v; }
    return Math.sqrt(s/data.length);
  }

  async function startVAD() {
    if (!useVAD || vadActive) return;
    try {
      vadStream   = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      vadAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const src   = vadAudioCtx.createMediaStreamSource(vadStream);
      vadAnalyser = vadAudioCtx.createAnalyser();
      vadAnalyser.fftSize = 256;
      src.connect(vadAnalyser);
      mimeType = detectMimeType();
      document.getElementById('chip-codec').textContent =
        'Codec: ' + (mimeType ? mimeType.split('/')[1].split(';')[0].toUpperCase() : 'default');
      vadActive = true; vadPaused = false; vadSpeaking = false;
      vadLoop();
      setStatus('active', 'Listening â€” speak your question');
    } catch(err) {
      showToast('ğŸ™ Microphone permission required');
    }
  }

  function stopVAD() {
    vadActive = false;
    cancelAnimationFrame(vadAnimFrame);
    clearTimeout(vadSilenceTimer); clearTimeout(vadSpeakTimer);
    if (vadRecorder && vadRecorder.state !== 'inactive') vadRecorder.stop();
    if (vadStream) { vadStream.getTracks().forEach(t=>t.stop()); vadStream=null; }
    if (vadAudioCtx) { vadAudioCtx.close(); vadAudioCtx=null; }
    vadSpeaking=false; vadPaused=false;
  }

  function pauseVAD() {
    vadPaused = true;
    if (vadRecorder && vadRecorder.state !== 'inactive') vadRecorder.stop();
    vadSpeaking = false;
    clearTimeout(vadSilenceTimer); clearTimeout(vadSpeakTimer);
  }

  function resumeVAD() {
    if (!vadActive) return;
    vadPaused   = false;
    vadSpeaking = false;
    clearTimeout(vadSpeakTimer);   vadSpeakTimer   = null;
    clearTimeout(vadSilenceTimer); vadSilenceTimer = null;
    setStatus('active', 'Listening â€” speak your question');
  }

  function vadLoop() {
    if (!vadActive) return;
    const data = new Uint8Array(vadAnalyser.fftSize);
    vadAnalyser.getByteTimeDomainData(data);
    const rms = getRMS(data);

    // Pick thresholds based on whether agent is currently speaking
    const threshold  = agentSpeaking ? VAD_THRESHOLD_BARGEIN  : VAD_THRESHOLD_NORMAL;
    const confirmMs  = agentSpeaking ? VAD_CONFIRM_BARGEIN_MS : VAD_CONFIRM_NORMAL_MS;

    // Don't listen while processing a request (but DO listen during agent speech for barge-in)
    if (!vadPaused && !requestInFlight) {
      if (!vadSpeaking) {
        if (rms > threshold) {
          if (!vadSpeakTimer) {
            vadSpeakTimer = setTimeout(() => {
              vadSpeakTimer = null;
              if (vadPaused || !vadActive || requestInFlight) return;
              // BARGE-IN: if agent is speaking, stop it immediately
              if (agentSpeaking) {
                clearQueue();        // stop all queued audio
                agentSpeaking = false;
                queueDoneCallback = null;
              }
              vadStartCapture();
            }, confirmMs);
          }
        } else { clearTimeout(vadSpeakTimer); vadSpeakTimer=null; }
      } else {
        if (rms < threshold) {
          if (!vadSilenceTimer) {
            vadSilenceTimer = setTimeout(() => {
              vadSilenceTimer=null;
              if (!vadSpeaking||vadPaused) return;
              vadStopCapture();
            }, VAD_SILENCE_MS);
          }
        } else { clearTimeout(vadSilenceTimer); vadSilenceTimer=null; }
      }
    } else if (requestInFlight) {
      // Clear any pending speak timer so we don't fire after request completes
      clearTimeout(vadSpeakTimer); vadSpeakTimer=null;
    }

    vadAnimFrame = requestAnimationFrame(vadLoop);
  }

  function vadStartCapture() {
    if (!vadStream||vadSpeaking||vadPaused) return;
    vadSpeaking=true; vadChunks=[]; vadSpeechStart=Date.now();
    const opts = mimeType ? {mimeType} : {};
    vadRecorder = new MediaRecorder(vadStream, opts);
    vadRecorder.ondataavailable = e => { if (e.data&&e.data.size>0) vadChunks.push(e.data); };
    vadRecorder.onstop = vadHandleStop;
    vadRecorder.start(250);
    isRecording=true;
    setStatus('recording', 'Recordingâ€¦');
  }

  function vadStopCapture() {
    if (!vadRecorder||vadRecorder.state==='inactive') return;
    vadSpeaking=false; isRecording=false;
    vadRecorder.stop();
    clearTimeout(vadSilenceTimer); vadSilenceTimer=null;
  }

  async function vadHandleStop() {
    const duration = Date.now() - vadSpeechStart;
    if (duration < VAD_MIN_SPEECH_MS || vadChunks.length===0) {
      isRecording=false;
      if (!vadPaused&&callActive) resumeVAD();
      return;
    }
    // Pause VAD while processing â€” we don't want to pick up our own question again
    pauseVAD();
    requestInFlight = true;
    setStatus('thinking', 'Processingâ€¦');
    showStatusMsg('Thinkingâ€¦');
    const ext  = mimeToExt(mimeType);
    const blob = new Blob(vadChunks, {type: mimeType||'audio/webm'});
    if (blob.size < 500) {
      showToast('Audio too short, try again');
      requestInFlight = false;
      if (callActive) resumeVAD();
      return;
    }
    await sendAudioStream(blob, ext);
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SSE STREAMING  (Android / Desktop)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  async function sendAudioStream(blob, ext) {
    const form = new FormData();
    form.append('session_id', sessionId);
    form.append('audio', blob, `recording.${ext}`);

    let agentBubble=null, agentFullText='';
    audioQueue=[]; queuePlaying=false;

    try {
      const res = await fetch('/api/query_stream', {method:'POST', body:form});
      if (!res.ok) throw new Error('Server error');
      const reader = res.body.getReader();
      const decoder= new TextDecoder();
      let buffer='';

      while (true) {
        const {done, value} = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, {stream:true});
        const lines = buffer.split('\n');
        buffer = lines.pop();
        for (const line of lines) {
          if (!line.startsWith('data: ')) continue;
          let event;
          try { event = JSON.parse(line.slice(6)); } catch { continue; }

          if (event.type === 'transcript') {
            removeStatusMsg();
            addBubble(event.text, 'user');
            showStatusMsg('Processing responseâ€¦');

          } else if (event.type === 'sentence') {
            agentFullText += (agentFullText ? ' ' : '') + event.text;
            if (!agentBubble) {
              removeStatusMsg();
              agentBubble = addBubble(event.text, 'agent');
            } else {
              agentBubble.textContent = 'ğŸ¤– ' + agentFullText;
              document.getElementById('transcript').scrollTop = 99999;
            }
            // Agent is speaking â€” unpause VAD with strict barge-in thresholds
            // so user can interrupt but background noise is ignored
            agentSpeaking   = true;
            requestInFlight = false;
            vadPaused       = false;   // KEY FIX: allow VAD loop to run for barge-in
            vadSpeaking     = false;
            clearTimeout(vadSpeakTimer); vadSpeakTimer = null;
            setStatus('active', 'Speakingâ€¦ (speak to interrupt)');
            enqueueAudio(event.audio_url);

          } else if (event.type === 'error') {
            showToast('âš ï¸ ' + event.text);

          } else if (event.type === 'done') {
            if (queuePlaying || audioQueue.length > 0) {
              queueDoneCallback = afterAgentDone;
            } else {
              afterAgentDone();
            }
          }
        }
      }
    } catch(err) {
      showToast('Network error. Please try again.');
      afterAgentDone();
    }
  }

  function afterAgentDone() {
    agentSpeaking   = false;
    requestInFlight = false;
    removeStatusMsg();
    if (callActive) {
      resumeVAD();
      showStatusMsg('Speak your next questionâ€¦');
    }
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     START CALL
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  async function startCall() {
    document.getElementById('start-btn').disabled = true;
    setStatus('thinking', 'Connectingâ€¦');

    try {
      const res  = await fetch('/api/start_call', {method:'POST'});
      const data = await res.json();
      if (!res.ok) throw new Error(data.error||'Start failed');

      sessionId=data.session_id; callActive=true;
      document.getElementById('end-btn').disabled = false;

      if (useVAD) {
        document.getElementById('mic-wrap').style.display = 'none';
        await startVAD();  // start VAD first so barge-in works during greeting
      }

      if (data.greeting_audio_url) {
        agentSpeaking = true;
        setStatus('active', 'Speakingâ€¦ (speak to interrupt)');
        await playAudio(data.greeting_audio_url);
        agentSpeaking = false;
      }

      addBubble('Hello, this is Institute of Space Technology. How can I help you today?', 'agent');

      if (useVAD) {
        showStatusMsg('Speak your next questionâ€¦');
        setStatus('active', 'Listening â€” speak your question');
      } else {
        // iOS: show mic button
        document.getElementById('mic-wrap').style.display = 'flex';
        setMicState('ready');
        setStatus('active', 'Connected â€” tap mic to speak');
        showStatusMsg('Tap the mic button to speak');
      }

    } catch(err) {
      showToast('âš ï¸ Failed to connect. Try again.');
      setStatus('offline', 'Offline â€” Click Start to begin');
      document.getElementById('start-btn').disabled = false;
    }
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     iOS MANUAL RECORDING
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  document.getElementById('mic-btn').addEventListener('click', () => {
    if (!callActive||useVAD) return;
    if (isRecording) stopRecording();
    else {
      if (currentAudio) { interruptAudio(); showToast('Interrupted â€” speak your question'); }
      startRecording();
    }
  });

  async function startRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({audio:true, video:false});
      mimeType = detectMimeType();
      document.getElementById('chip-codec').textContent =
        'Codec: ' + (mimeType ? mimeType.split('/')[1].split(';')[0].toUpperCase() : 'default');
      const options = mimeType ? {mimeType} : {};
      mediaRecorder = new MediaRecorder(stream, options);
      recordingChunks=[];
      mediaRecorder.ondataavailable = e => { if (e.data&&e.data.size>0) recordingChunks.push(e.data); };
      mediaRecorder.onstop = handleRecordingStop_iOS;
      mediaRecorder.start(1000);
      isRecording=true;
      setMicState('recording');
      setStatus('recording', 'Recordingâ€¦');
      removeStatusMsg();
    } catch(err) {
      showToast(err.name==='NotAllowedError' ? 'ğŸ™ Microphone permission denied' : 'ğŸ™ Could not access microphone');
    }
  }

  function stopRecording() {
    if (!mediaRecorder||mediaRecorder.state==='inactive') return;
    mediaRecorder.stop();
    mediaRecorder.stream.getTracks().forEach(t=>t.stop());
    isRecording=false;
  }

  async function handleRecordingStop_iOS() {
    setMicState('thinking'); setStatus('thinking', 'Processingâ€¦');
    showStatusMsg('Thinkingâ€¦');
    const ext  = mimeToExt(mimeType);
    const blob = new Blob(recordingChunks, {type: mimeType||'audio/webm'});
    if (blob.size < 500) {
      showToast('Recording too short â€” please try again');
      setMicState('ready'); setStatus('active', 'Connected â€” tap mic to speak');
      removeStatusMsg(); showStatusMsg('Tap the mic button to speak');
      return;
    }
    const form = new FormData();
    form.append('session_id', sessionId);
    form.append('audio', blob, `recording.${ext}`);
    try {
      const res  = await fetch('/api/query', {method:'POST', body:form});
      const data = await res.json();
      if (!res.ok||data.error) {
        showToast('âš ï¸ ' + (data.error||'Server error'));
      } else {
        if (data.user_text) addBubble(data.user_text, 'user');
        if (data.response)  addBubble(data.response, 'agent');
        if (data.audio_url) {
          setMicState('speaking'); setStatus('active', 'Speakingâ€¦ (tap ğŸ™ to interrupt)');
          showStatusMsg('Speakingâ€¦');
          await playAudio(data.audio_url);
        }
      }
    } catch(err) {
      showToast('Network error. Please try again.');
    } finally {
      if (callActive) {
        setMicState('ready'); setStatus('active', 'Connected â€” tap mic to speak');
        removeStatusMsg(); showStatusMsg('Tap the mic button to speak');
      }
    }
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     END CALL
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  async function endCall() {
    if (!callActive) return;
    callActive=false; clearQueue();
    agentSpeaking=false; requestInFlight=false;
    if (useVAD) stopVAD(); else if (isRecording) stopRecording();
    document.getElementById('start-btn').disabled = false;
    document.getElementById('end-btn').disabled   = true;
    document.getElementById('mic-wrap').style.display = 'none';
    setMicState('idle');
    setStatus('offline', 'Ended â€” Click Start to begin again');
    removeStatusMsg();
    try {
      await fetch('/api/end_call', {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({session_id: sessionId})
      });
    } catch(_) {}
    sessionId=null;
    showToast('Call ended. Thank you!');
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     INIT
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  window.addEventListener('load', () => {
    if (!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)
      showToast('âš ï¸ Browser does not support audio recording');
    setStatus('offline', 'Offline â€” Click Start to begin');
    document.getElementById('mic-wrap').style.display = 'none';
  });
  </script>
</body>
</html>